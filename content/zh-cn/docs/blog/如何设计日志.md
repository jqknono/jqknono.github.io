---
title: 如何设计日志
---

# 如何设计日志

以下仅为个人对程序记录日志的一些浅显的思考, 欢迎交流.


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [如何设计日志](#如何设计日志)
  - [日志记录什么](#日志记录什么)
  - [日志的困境](#日志的困境)
  - [日志引发的安全问题](#日志引发的安全问题)
  - [日志收敛](#日志收敛)
  - [分析日志](#分析日志)
  - [日志道德](#日志道德)

<!-- /code_chunk_output -->


## 日志记录什么

日志是一种记录信息的方式, 通常是记录程序运行的信息, 例如: 程序运行的时间, 程序运行的结果, 程序运行的错误等等.

程序的基本构成是数据和业务逻辑, 针对这两类构成, 日志表达的信息不同:

- **数据日志**: 输入数据, 输出数据, 中间数据等;
- **逻辑日志**: 是否进入分支, 是否进入循环, 是否进入异常处理等.

可以观察到, 数据日志记录的是一种状态, 我们关注状态的转换是否符合预期;
而逻辑日志通常记录的是一种事件, 需要关注事件是否发生, 事件发生的顺序是否正确.

## 日志的困境

许多项目的日志存在两个问题:

- 日志太多, 有用信息隐藏在茫茫大海中
- 日志太少, 关键信息缺失

我们先假定一个前提, 人们通常在**出现问题**时才去查看日志, 80%的日志应该为此目标服务, 剩余的日志则是为了其它目标服务.

根据此主要目标, 我们应用奥卡姆剃刀原则, 仅保留必要的日志, 识别并减少低价值的日志.

1. 如果一条日志可以以其它方式获取, 则没有必要记录日志. 例如: 可以通过**调试器**获取的过程信息, 不应该记录日志.
   - 开发常见的操作是基于对自己逻辑的不自信, 在关键位置打印日志, 以便于查看程序运行的过程, 但存在一个问题, 一旦业务逻辑运行正常, 这些日志就没有意义了. 因此, 应避免中间过程信息的日志.
   - 当删除掉关键处理逻辑的数据日志时, 应该补充记录输入参数的数据日志, 以及逻辑日志, 依靠入参信息, 必需可以复现问题场景.
1. 如果一条日志可以通过其它日志推导出, 则没有必要记录日志.
   - 如果确定一个子任务没有对数据进行修改, 那么没有必要记录多条数据日志, 没有必要记录一份不会产生状态迁移的数据.
   - 如果确定一个子任务没有分支, 那么没有必要记录多条逻辑日志, 一个事件发生时, 关联事件必然发生, 则只需要记录一次.
1. 如果一条日志不能明确将记录什么, 则应该明确后再记录日志.
   - 未知的错误处理, 应该转为已知的错误处理, 然后再记录日志.
   - 未知的入参数据结构, 应转为已知的数据结构

简单的讲, 记录输入和异常, 而不是中间过程的数据和正常的结果. 我们希望能通过分析日志, 确认在何时产生了一个明确的错误, 并能依据日志构造一个明确的输入用例, 提供给开发后, 此用例应该已足够构造异常场景. 而开发应该使用调试器, 通过断点, 来查看程序运行的过程, 而不是通过日志.

## 日志引发的安全问题

设计良好的日志, 可以帮助我们分析问题, 但是设计不良的日志, 可能带来安全问题.

日志系统应该架构简单, 职责单一, 不得参与任何业务逻辑, 不建议使用"瑞士军刀"型的日志系统, 曾经爆发过一次 log4j 的安全漏洞, 该漏洞导致了数百万的服务器被入侵, [Log4J 漏洞事件回顾](https://www.orangecyberdefense.com/cn/insights/analysis/log4j-vulnerability-review).

## 日志收敛

日志的存储占用了磁盘或内存空间, 不应该无限增长, 针对超量日志常见有两类做法:

- 老化
  - 保留最近一周的日志, 超过一周的日志则删除;
  - 仅保留最近的 1000 条日志, 覆盖旧的日志;
- 压缩
  - 保留最近一周的日志, 超过一周的日志则压缩;
  - 聚合相同的日志, 仅保留一条.

我们还可以考虑**放弃记录**, 日志的超量记录可能成为程序的一个攻击面, 无法退出的循环, 无法退出的递归, 无法退出的异常处理等, 都可能导致日志无限增长, 甚至导致程序崩溃, 为了避免这种情况, 我们可以放弃记录这些日志.

可以通过计数器/聚合器等识别异常日志, 选择放弃记录, 甚至强制退出业务.

## 分析日志

从日志中分析出有用信息, 我们并不太需要什么日志分析工具, 它们多只是日志监控器或计数器, 操作前提基于我们本身已理解日志.
分析陌生日志, 需要关注以下信息:

- 时间节点: 日志中记录的时间节点, 有助于我们分析日志的执行顺序, 以及日志的时序关系;
- 进程线程 id: 日志可能未连贯记录任务执行的完整过程, 但我们可以通过进程线程 id, 将日志关联起来, 以便分析;
- 关键词: Error, Exception, Warning, Fatal, Info 以及可识别的自定义的关键词;
- 业务逻辑, 识别过程和函数名
  - 关注词汇: Get, Set, Add, Delete, Update, Insert, Select, Query, Search, Find, List, Count, 以及自定义的关键词, 有助于我们快速定位业务逻辑;
  - 关注返回值: ret, code, status, 有助于分析业务逻辑的执行结果;

我们已经知道日志中记录了数据和业务逻辑,

- 逻辑日志通常仅记录时间节点, 信息量较少, 难以获取关键数据, 但逻辑日志倘若记录了函数名, 过程名, 我们便能推断出业务逻辑的执行过程, 从而分析出可能存在的漏洞;
- 数据日志记录了状态, 信息量较多, 可以根据输入和输出数据逆推业务逻辑, 再构造具有攻击行为的输入数据, 从而分析出可能存在的漏洞;

## 日志道德

日志行为不规范, 一方面带来信息泄露的安全问题, 另一方面可能带来用户投诉, 甚至法律纠纷.

日志行为应该受到约束:

- 敏感信息不应记录日志, 比如使用者的个人信息, 包括账号, 密码/密钥等.
- 用户协议承诺不收集的信息, 不应该呈现不必要的收集过程

何为敏感信息, 我们定义用户的设备和数据为**用户资产**, 程序运行在用户设备上, 用户即是第一方, 程序提供者是第二方, 其它参与提供服务的是第三方, 用户总是希望:

- 第二方尽量少的使用用户资产, 甚至不使用用户资产;
- 第二方尽量少的向第三方提供用户资产, 甚至不提供用户资产;

简而言之, 第一方不希望自己的任何资产信息出现在日志中, 第一方不希望在窥探第二方和第三方的业务过程中, 发现自己被窥探.
